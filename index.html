<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>POLYGON EXODUS</title>
<style>
html, body { margin:0; padding:0; background:#0b0b0b; color:#fff; font-family:'SF Pro', sans-serif; overflow:hidden; }
canvas { display:block; }
#ui { position: fixed; top:10px; right:10px; background: rgba(0,0,0,0.7); padding:12px; border-radius:10px; width:260px; font-size:14px; }
#leaderboard { margin-top:8px; max-height:180px; overflow-y:auto; font-size:13px; position:relative; }
.lb-row { display:flex; justify-content:space-between; opacity:0.85; position:relative; animation: floatUpDown 2s infinite alternate; }
@keyframes floatUpDown { 0%{top:0px;} 100%{top:4px;} }
.comboText { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-weight:bold; font-style:italic; font-size:22px; animation: floatCombo 1s ease-out forwards; pointer-events:none; }
@keyframes floatCombo { 0%{opacity:1; top:10px;} 100%{opacity:0; top:-40px;} }
button { width:100%; padding:6px; margin:4px 0; border-radius:6px; border:none; cursor:pointer; font-weight:bold; }
button:hover{opacity:0.85;}
</style>
</head>
<body>

<div id="ui">
  <div><b>Player</b></div>
  <hr>
  <div>Mass: <span id="mass">0</span></div>
  <div>Shape: <span id="tier">Triangle</span></div>
  <div>Tokens: <span id="tokens">0</span></div>
  <hr>
  <b>Leaderboard</b>
  <div id="leaderboard"></div>
  <button id="idleBtn">IDLE MODE</button>
  <button id="exitIdleBtn" style="display:none;">EXIT IDLE MODE</button>
  <button id="saveLoadBtn">SAVE / LOAD</button>
</div>

<canvas id="game"></canvas>

<div id="savePanel" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.75);z-index:999;">
  <div style="width:420px;background:#111;border:2px solid #555;padding:14px;margin:10% auto;border-radius:10px;">
    <b>Save / Load Game</b>
    <textarea id="saveText" style="width:100%;height:120px;margin-top:10px;background:#000;color:#0f0;font-family:monospace;resize:none;"></textarea>
    <button id="saveBtn">GENERATE SAVE</button>
    <button id="loadBtn">LOAD GAME</button>
    <button id="closeSave">CLOSE</button>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = innerWidth; canvas.height = innerHeight;
window.addEventListener('resize',()=>{canvas.width=innerWidth; canvas.height=innerHeight;});

/* BACKGROUND */
const bgImg = new Image(); bgImg.src="bg.png";
const bgImg2 = new Image(); bgImg2.src="goonerola.png";
const bgObj={x:canvas.width/2,y:canvas.height/2,vx:(Math.random()*0.6+0.2)*(Math.random()<0.5?-1:1),vy:(Math.random()*0.6+0.2)*(Math.random()<0.5?-1:1),size:39};
const bgObj2={x:Math.random()*canvas.width,y:Math.random()*canvas.height,vx:(Math.random()*0.7+0.3)*(Math.random()<0.5?-1:1),vy:(Math.random()*0.7+0.3)*(Math.random()<0.5?-1:1),size:36};

/* PLAYER */
let player={x:canvas.width/2,y:canvas.height/2,r:18,angle:0,tokens:0,health:100,rainbow:false};
let currentShapeSides=3;

/* GAME DATA */
let bullets=[],enemies=[],particles=[];
let keys={},idleMode=false,idleInterval=null;
let combo=0,mass=0,difficulty=1,hUses=12;

/* BLUE CUBE */
let blueCube = null;
let nextCubeSpawn = Date.now() + (30000 + Math.random()*30000);
let enemyOriginalSpeeds = new Map();

function updateBlueCube(deltaTime){
  if(!blueCube && Date.now()>=nextCubeSpawn){
    // spawn at center, slightly bigger than enemies (enemy r = 8)
    blueCube = { x: canvas.width/2, y: canvas.height/2, size:18, speed:80 };
  }

  if(blueCube){
    const dx = blueCube.x - player.x;
    const dy = blueCube.y - player.y;
    const dist = Math.hypot(dx,dy)||1;
    const moveDist = blueCube.speed * deltaTime / 1000;
    blueCube.x += (dx/dist) * moveDist;
    blueCube.y += (dy/dist) * moveDist;

    blueCube.x = Math.max(blueCube.size/2, Math.min(canvas.width-blueCube.size/2, blueCube.x));
    blueCube.y = Math.max(blueCube.size/2, Math.min(canvas.height-blueCube.size/2, blueCube.y));

    if(dist < blueCube.size/2 + player.r){
      enemies.forEach(e=>{
        if(!enemyOriginalSpeeds.has(e)) enemyOriginalSpeeds.set(e,0.7+difficulty*0.2);
        e.speed = (0.7+difficulty*0.2)*0.2;
      });
      blueCube = null;
      nextCubeSpawn = Date.now() + (30000 + Math.random()*30000);
      setTimeout(()=>{ 
        enemies.forEach(e=>{e.speed = enemyOriginalSpeeds.get(e) || (0.7+difficulty*0.2); });
        enemyOriginalSpeeds.clear(); 
      },5000);
    }
  }
}

function drawBlueCube(){
  if(!blueCube) return;
  const radius = 4; // rounded corners
  ctx.fillStyle="blue";
  ctx.strokeStyle="#0ff";
  ctx.lineWidth=2;

  ctx.beginPath();
  ctx.moveTo(blueCube.x - blueCube.size/2 + radius, blueCube.y - blueCube.size/2);
  ctx.lineTo(blueCube.x + blueCube.size/2 - radius, blueCube.y - blueCube.size/2);
  ctx.quadraticCurveTo(blueCube.x + blueCube.size/2, blueCube.y - blueCube.size/2, blueCube.x + blueCube.size/2, blueCube.y - blueCube.size/2 + radius);
  ctx.lineTo(blueCube.x + blueCube.size/2, blueCube.y + blueCube.size/2 - radius);
  ctx.quadraticCurveTo(blueCube.x + blueCube.size/2, blueCube.y + blueCube.size/2, blueCube.x + blueCube.size/2 - radius, blueCube.y + blueCube.size/2);
  ctx.lineTo(blueCube.x - blueCube.size/2 + radius, blueCube.y + blueCube.size/2);
  ctx.quadraticCurveTo(blueCube.x - blueCube.size/2, blueCube.y + blueCube.size/2, blueCube.x - blueCube.size/2, blueCube.y + blueCube.size/2 - radius);
  ctx.lineTo(blueCube.x - blueCube.size/2, blueCube.y - blueCube.size/2 + radius);
  ctx.quadraticCurveTo(blueCube.x - blueCube.size/2, blueCube.y - blueCube.size/2, blueCube.x - blueCube.size/2 + radius, blueCube.y - blueCube.size/2);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

/* FIRST TIME CIRCLE MESSAGE */
let firstCircleShown = false;
function checkFirstCircle(){
  if(currentShapeSides === 100 && !firstCircleShown){
    firstCircleShown = true;
    const msg = document.createElement('div');
    msg.textContent = "whoa, ur a circle now. HIGH FIVE! ðŸ˜œ";
    msg.style.position = 'fixed';
    msg.style.bottom = '20px';
    msg.style.left = '50%';
    msg.style.transform = 'translateX(-50%)';
    msg.style.fontFamily = "'SF Pro', sans-serif";
    msg.style.fontWeight = '600';
    msg.style.fontStyle = 'italic';
    msg.style.fontSize = '22px';
    msg.style.background = 'transparent';
    msg.style.pointerEvents = 'none';
    msg.style.color = 'hsl(0,100%,50%)';
    msg.style.zIndex = 999;
    document.body.appendChild(msg);

    let hue = 0;
    const rainbowInterval = setInterval(()=>{
      hue = (hue+3)%360;
      msg.style.color = `hsl(${hue},100%,50%)`;
    },30);

    setTimeout(()=>{
      clearInterval(rainbowInterval);
      msg.remove();
    },4000);
  }
}

/* UPDATE */
function update(){
  const now = performance.now();

  if(!idleMode){ if(keys.w)player.y-=4; if(keys.s)player.y+=4; if(keys.a)player.x-=4; if(keys.d)player.x+=4; }
  else{ player.x+=(canvas.width/2-player.x)*0.05; player.y+=(canvas.height/2-player.y)*0.05; }
  player.angle+=0.08;

  // bullets
  for(let bi=bullets.length-1;bi>=0;bi--){ let b=bullets[bi]; b.x+=b.vx; b.y+=b.vy; if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) bullets.splice(bi,1); }

  // enemies
  for(let ei=enemies.length-1;ei>=0;ei--){ 
    let e=enemies[ei]; const dx=player.x-e.x, dy=player.y-e.y, d=Math.hypot(dx,dy)||1; 
    if(e.speed === undefined) e.speed = 0.7 + difficulty*0.2;
    e.x += dx/d * e.speed; e.y += dy/d * e.speed;
    if(d<player.r+e.r){ const idx=shapeOrder.indexOf(currentShapeSides); currentShapeSides=shapeOrder[Math.max(0,idx-3)]; combo=0; player.rainbow=false; shakeCamera(5); enemies.splice(ei,1);}
    if(e.x<-50||e.x>canvas.width+50||e.y<-50||e.y>canvas.height+50) enemies.splice(ei,1);
  }

  // bullets hit enemies
  for(let bi=bullets.length-1;bi>=0;bi--){ let b=bullets[bi]; for(let ei=enemies.length-1;ei>=0;ei--){ let e=enemies[ei]; if(Math.hypot(b.x-e.x,b.y-e.y)<e.r){ bullets.splice(bi,1); enemies.splice(ei,1); createExplosion(e.x,e.y); mass++; player.tokens++; evolve(); combo++; shakeCamera(8); if(mass%20===0) difficulty++; if(combo>1) showCombo(combo); if(combo>=35&&!player.rainbow) player.rainbow=true; break; } } }

  // particles
  for(let pi=particles.length-1;pi>=0;pi--){ let p=particles[pi]; p.x+=p.vx; p.y+=p.vy; p.alpha-=0.03; if(p.alpha<=0) particles.splice(pi,1); }

  // background
  bgObj.x+=bgObj.vx; bgObj.y+=bgObj.vy; if(bgObj.x<bgObj.size||bgObj.x>canvas.width-bgObj.size) bgObj.vx*=-1; if(bgObj.y<bgObj.size||bgObj.y>canvas.height-bgObj.size) bgObj.vy*=-1;
  bgObj2.x+=bgObj2.vx; bgObj2.y+=bgObj2.vy; if(bgObj2.x<bgObj2.size||bgObj2.x>canvas.width-bgObj2.size) bgObj2.vx*=-1; if(bgObj2.y<bgObj2.size||bgObj2.y>canvas.height-bgObj2.size) bgObj2.vy*=-1;

  document.getElementById('mass').textContent=mass;
  document.getElementById('tokens').textContent=player.tokens;
  document.getElementById('tier').textContent=getShapeName(currentShapeSides);
  player.x=Math.max(player.r,Math.min(canvas.width-player.r,player.x));
  player.y=Math.max(player.r,Math.min(canvas.height-player.r,player.y));

  // check first circle message
  checkFirstCircle();

  // update blue cube
  updateBlueCube(now - (updateBlueCube.lastTime || now));
  updateBlueCube.lastTime = now;
}

// ... rest of your original code remains unchanged ...

</script>
</body>
</html>
