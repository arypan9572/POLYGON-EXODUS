<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>POLYGON EXODUS</title>
<style>
html, body {
  margin:0;
  padding:0;
  background:#0b0b0b;
  color:#fff;
  font-family:'SF Pro', sans-serif;
  overflow:hidden;
}
canvas { display:block; }
#ui {
  position: fixed;
  top:10px;
  right:10px;
  background: rgba(0,0,0,0.7);
  padding:12px;
  border-radius:10px;
  width:260px;
  font-size:14px;
}
button {
  width:100%;
  padding:6px;
  margin:4px 0;
  border-radius:6px;
  border:none;
  cursor:pointer;
  font-weight:bold;
}
button:hover{opacity:0.85;}
</style>
</head>

<body>
<div id="ui">
  <div><b>Player</b></div>
  <hr>
  <div>Mass: <span id="mass">0</span></div>
  <div>Shape: <span id="tier">Triangle</span></div>
  <div>Tokens: <span id="tokens">0</span></div>
  <hr>
  <button id="idleBtn">IDLE MODE</button>
  <button id="exitIdleBtn" style="display:none;">EXIT IDLE MODE</button>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = innerWidth;
canvas.height = innerHeight;
addEventListener('resize',()=>{canvas.width=innerWidth;canvas.height=innerHeight});

/* PLAYER */
let player={x:canvas.width/2,y:canvas.height/2,r:18,angle:0,tokens:0,rainbow:false};
let currentShapeSides=3;

/* GAME DATA */
let bullets=[],enemies=[],eliteEnemies=[],particles=[];
let keys={},idleMode=false,idleInterval=null;
let combo=0,mass=0,difficulty=1,hUses=12;

/* FIRE (UNCHANGED) */
function fireSingle(){
  bullets.push({
    x:player.x,
    y:player.y,
    vx:Math.cos(player.angle)*6,
    vy:Math.sin(player.angle)*6,
    rainbow:false
  });
}
function fireSpread(){
  for(let i=0;i<8;i++){
    const a=i*Math.PI*2/8+player.angle;
    bullets.push({
      x:player.x,
      y:player.y,
      vx:Math.cos(a)*7,
      vy:Math.sin(a)*7,
      rainbow:false
    });
  }
}

/* ENEMIES */
function spawnEnemy(){
  enemies.push({
    x:Math.random()<0.5?-20:canvas.width+20,
    y:Math.random()*canvas.height,
    r:8
  });
}
setInterval(spawnEnemy,800);

/* ðŸ”¥ ELITE HEX ENEMY */
function spawnElite(){
  eliteEnemies.push({
    x:Math.random()<0.5?-40:canvas.width+40,
    y:Math.random()*canvas.height,
    r:18,
    hp:30
  });
}
setInterval(spawnElite,75000);

/* UPDATE */
function update(){
  if(!idleMode){
    if(keys.w) player.y-=4;
    if(keys.s) player.y+=4;
    if(keys.a) player.x-=4;
    if(keys.d) player.x+=4;
  } else {
    player.x+=(canvas.width/2-player.x)*0.05;
    player.y+=(canvas.height/2-player.y)*0.05;
  }

  player.angle+=0.08;

  bullets.forEach((b,i)=>{
    b.x+=b.vx; b.y+=b.vy;
    if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height)
      bullets.splice(i,1);
  });

  enemies.forEach((e,ei)=>{
    const dx=player.x-e.x,dy=player.y-e.y,d=Math.hypot(dx,dy)||1;
    e.x+=dx/d*(0.7+difficulty*0.2);
    e.y+=dy/d*(0.7+difficulty*0.2);

    bullets.forEach((b,bi)=>{
      if(Math.hypot(b.x-e.x,b.y-e.y)<e.r){
        bullets.splice(bi,1);
        enemies.splice(ei,1);
        mass++; player.tokens++;
      }
    });
  });

  eliteEnemies.forEach((e,ei)=>{
    const dx=player.x-e.x,dy=player.y-e.y,d=Math.hypot(dx,dy)||1;
    e.x+=dx/d*0.6;
    e.y+=dy/d*0.6;

    bullets.forEach((b,bi)=>{
      if(Math.hypot(b.x-e.x,b.y-e.y)<e.r){
        bullets.splice(bi,1);
        e.hp--;
        if(e.hp<=0){
          eliteEnemies.splice(ei,1);
          mass+=10;
        }
      }
    });

    if(e.x<-60||e.x>canvas.width+60||e.y<-60||e.y>canvas.height+60)
      eliteEnemies.splice(ei,1);
  });

  document.getElementById('mass').textContent=mass;
  document.getElementById('tokens').textContent=player.tokens;
}

/* DRAW */
function draw(){
  ctx.fillStyle="rgba(11,11,11,0.25)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  drawPlayerShape();

  bullets.forEach(b=>{
    ctx.fillStyle="#fff";
    ctx.fillRect(b.x,b.y,3,3);
  });

  enemies.forEach(e=>{
    ctx.fillStyle="red";
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.r,0,Math.PI*2);
    ctx.fill();
  });

  eliteEnemies.forEach(e=>{
    ctx.save();
    ctx.translate(e.x,e.y);
    ctx.strokeStyle="#c77dff";
    ctx.lineWidth=3;
    ctx.shadowColor="#c77dff";
    ctx.shadowBlur=15;
    ctx.fillStyle="#000";
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const a=i*Math.PI*2/6-Math.PI/2;
      ctx.lineTo(Math.cos(a)*e.r,Math.sin(a)*e.r);
    }
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.shadowBlur=0;
    ctx.fillStyle="#c77dff";
    ctx.textAlign="center";
    ctx.fillText(e.hp,0,-e.r-10);
    ctx.restore();
  });
}

/* DRAW PLAYER */
function drawPlayerShape(){
  ctx.save();
  ctx.translate(player.x,player.y);
  ctx.rotate(player.angle);
  ctx.fillStyle="#4caf50";
  ctx.beginPath();
  for(let i=0;i<currentShapeSides;i++){
    const a=i*Math.PI*2/currentShapeSides-Math.PI/2;
    ctx.lineTo(Math.cos(a)*player.r,Math.sin(a)*player.r);
  }
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

/* LOOP */
function loop(){update();draw();requestAnimationFrame(loop);}
loop();

/* INPUT */
addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key===' '&&!idleMode) fireSingle();
  if(e.key.toLowerCase()==='h'&&!idleMode&&hUses>0){ fireSpread(); hUses--; }
});
addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

/* IDLE MODE */
idleBtn.onclick=()=>{
  idleMode=true;
  idleBtn.style.display='none';
  exitIdleBtn.style.display='block';
  idleInterval=setInterval(()=>fireSingle(),1000);
};
exitIdleBtn.onclick=()=>{
  idleMode=false;
  clearInterval(idleInterval);
  idleBtn.style.display='block';
  exitIdleBtn.style.display='none';
};
</script>
</body>
</html>
