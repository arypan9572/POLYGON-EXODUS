<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>POLYGON EXODUS</title>
  

<!-- FAVICONS -->
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
<link rel="shortcut icon" type="image/png" href="favicon.png">

<!-- SF Pro Display CDN -->
<link href="https://fonts.cdnfonts.com/css/sf-pro-display" rel="stylesheet">

<style>
html, body { margin:0; padding:0; background:#0b0b0b; color:#fff; font-family:'SF Pro', sans-serif; overflow:hidden; }
canvas { display:block; }

/* UI */
#ui { position: fixed; top:10px; right:10px; background: rgba(0,0,0,0.7); padding:12px; border-radius:10px; width:260px; font-size:14px; }
#leaderboard { margin-top:8px; max-height:180px; overflow-y:auto; font-size:13px; position:relative; }
.lb-row { display:flex; justify-content:space-between; opacity:0.85; position:relative; animation: floatUpDown 2s infinite alternate; }
@keyframes floatUpDown { 0%{top:0px;} 100%{top:4px;} }
.comboText { position:absolute; top:10px; left:50%; transform:translateX(-50%); font-weight:bold; font-style:italic; font-size:22px; animation: floatCombo 1s ease-out forwards; pointer-events:none; }
@keyframes floatCombo { 0%{opacity:1; top:10px;} 100%{opacity:0; top:-40px;} }
/* DEFAULT GAME BUTTONS (small, original size) */
button {
  padding: 6px 10px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
}

/* TITLE SCREEN BUTTONS ONLY */
#titleScreen button {
  width: 200px;
  padding: 10px;
  margin: 10px 0;
  font-weight: bold;
  font-size: 18px;
  border-radius: 8px;
}


button:hover{opacity:0.85;}

/* TITLE SCREEN */
#titleScreen {
  position: fixed; inset:0; background: #0b0b0b; z-index: 1000; display:flex;
  flex-direction: column; justify-content:center; align-items:center; overflow:hidden;
}
#titleLogo {
  width: 400px;
  opacity: 0;
  animation: fadeInMoveLogo 2s forwards, floatLogo 4s ease-in-out infinite alternate;
}
#startBtn, #hardBtn {
  font-size: 24px;
  width: 200px;
  margin-top: 40px;
  opacity: 0;
  animation: fadeInMoveBtn 2s 0.5s forwards, floatBtn 3s ease-in-out infinite alternate;
}
@keyframes fadeInMoveLogo { 0% { opacity:0; transform:translateY(50px); } 100% { opacity:1; transform:translateY(0); } }
@keyframes fadeInMoveBtn { 0% { opacity:0; transform:translateY(60px); } 100% { opacity:1; transform:translateY(0); } }
@keyframes floatLogo { 0% { transform:translateY(0); } 100% { transform:translateY(20px); } }
@keyframes floatBtn { 0% { transform:translateY(0); } 100% { transform:translateY(35px); } }
@keyframes floatSlow   { from{transform:translateY(0);} to{transform:translateY(14px);} }
@keyframes floatMedium { from{transform:translateY(0);} to{transform:translateY(20px);} }
@keyframes floatFast   { from{transform:translateY(0);} to{transform:translateY(26px);} }

#heartsUI {
  position: fixed;
  top: 14px;
  left: 14px;
  display: flex;
  gap: 8px;
  z-index: 500;
}

.heart {
  width: 26px;
  height: 26px;
  background: red;
  clip-path: polygon(
    50% 80%,
    100% 35%,
    75% 0%,
    50% 20%,
    25% 0%,
    0% 35%
  );
}


</style>
</head>
<body>

<!-- TITLE SCREEN -->
<div id="titleScreen">
  <img id="titleLogo" src="polyex.png" alt="POLYGON EXODUS Logo">

  <!-- MODE SELECT -->
 <div id="modeSelect" style="display:flex; flex-direction:column; align-items:center; margin-top:40px; animation:floatSlow 4s ease-in-out infinite alternate;">

  <div style="display:flex; gap:80px;">
    <button id="classicBtn" style="width:180px;">CLASSIC</button>
    <button id="arcadeBtn" style="width:180px;">ARCADE</button>
  </div>

  <button id="settingsBtn" style="width:100px; font-size:16px; margin-top:20px;">
    SETTINGS
  </button>

   <button id="catalogBtn" style="width:100px; font-size:16px; margin-top:10px;">
  CATALOG
</button>

</div>

  <!-- CLASSIC OPTIONS -->
 <div id="classicOptions" style="display:none; margin-top:40px; width:240px; animation:floatMedium 3.2s ease-in-out infinite alternate;">

    <button id="startBtn">START GAME</button>
    <button id="hardBtn">HARD MODE</button>
  </div>

  <!-- ARCADE OPTIONS -->
 <div id="arcadeOptions" style="display:none; margin-top:40px; width:240px; animation:floatFast 2.8s ease-in-out infinite alternate;">

   

    <button id="survivorBtn">SURVIVOR</button>
    <button disabled>SWITCHUP (Coming Soon)</button>
  </div>

  <!-- SETTINGS OPTIONS -->
<div id="settingsOptions" style="display:none; margin-top:40px; width:240px;">
  <button id="lightModeBtn">LIGHT MODE</button>
  <button id="darkModeBtn">DARK MODE</button>
</div>

</div>

<div id="catalogPanel" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:1000; color:white; font-family:'SF Pro',sans-serif; padding:40px; overflow:hidden;">
  <h1 style="text-align:center;">CATALOG</h1>
  <div id="catalogContent" style="text-align:center; font-size:18px; margin-top:20px;"></div>
  <div style="text-align:center; margin-top:40px;">
    <button id="catalogLeftBtn" style="margin-right:50px;">A</button>
    <button id="catalogRightBtn">D</button>
    <button id="catalogCloseBtn" style="margin-left:50px;">BACK</button>
  </div>
</div>


<audio id="menuMusic" src="mm.mp3" loop></audio>
<audio id="btnHover" src="btnhvr.mp3"></audio>
<audio id="btnClick" src="btnclk.mp3"></audio>
<audio id="gameMusic" src="Exodus.mp3" loop></audio>


<div id="ui">
  <div><b>Player</b></div>
  <hr>
  <div>Mass: <span id="mass">0</span></div>
  <div>Shape: <span id="tier">Triangle</span></div>
  <div>Tokens: <span id="tokens">0</span></div>
  <div>High Score: <span id="highScore">0</span></div>

  <hr>
  <b>Leaderboard</b>
  <div id="leaderboard"></div>
  <button id="idleBtn">IDLE MODE</button>
  <button id="exitIdleBtn" style="display:none;">EXIT IDLE MODE</button>
  <button id="saveLoadBtn">SAVE / LOAD</button>
 

</div>

<canvas id="transitionCanvas" style="position:fixed;inset:0;z-index:1500;pointer-events:none;display:none;"></canvas>
<canvas id="game"></canvas>

<div id="heartsUI"></div>

<button id="backBtn" style="position:fixed;top:14px;right:14px;z-index:500;display:none;">BACK</button>
  
<div id="savePanel" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.75);z-index:999;">
  <div style="width:420px;background:#111;border:2px solid #555;padding:14px;margin:10% auto;border-radius:10px;">
    <b>Save / Load Game</b>
    <textarea id="saveText" style="width:100%;height:120px;margin-top:10px;background:#000;color:#0f0;font-family:monospace;resize:none;"></textarea>
    <button id="saveBtn">GENERATE SAVE</button>
    <button id="loadBtn">LOAD GAME</button>
    <button id="closeSave">CLOSE</button>
  </div>
</div>

<script>
/* ==== SETUP ==== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = innerWidth; canvas.height = innerHeight;
window.addEventListener('resize',()=>{ canvas.width=innerWidth; canvas.height=innerHeight; });

const gameMusic = document.getElementById('gameMusic');

const menuMusic = document.getElementById('menuMusic');

// === MENU MUSIC AUTOPLAY FIX ===
let menuMusicStarted = false;
function playMenuMusicOnce() {
  if(!menuMusicStarted){
    menuMusic.play().catch(()=>console.log("Menu music blocked until click"));
    menuMusicStarted = true;
  }
}

// Play menu music on first click anywhere
window.addEventListener("click", playMenuMusicOnce, { once: true });


/* ==== BACKGROUND ==== */
const bgImg = new Image(); bgImg.src="bg.png";
const bgImg2 = new Image(); bgImg2.src="goonerola.png";
const bgObj={x:canvas.width/2,y:canvas.height/2,vx:(Math.random()*0.6+0.2)*(Math.random()<0.5?-1:1),vy:(Math.random()*0.6+0.2)*(Math.random()<0.5?-1:1),size:39,angle: 0,
};
const bgObj2={x:Math.random()*canvas.width,y:Math.random()*canvas.height,vx:(Math.random()*0.7+0.3)*(Math.random()<0.5?-1:1),vy:(Math.random()*0.7+0.3)*(Math.random()<0.5?-1:1),size:36};

/* ==== PLAYER ==== */
let player={x:canvas.width/2,y:canvas.height/2,r:18,angle:0,tokens:0,health:100,rainbow:false};
let currentShapeSides=3;
let bulletMultiplier=1;
let hardMode=false;
let colorMode = "dark"; // "dark" or "light"


/* ==== GAME STATE ==== */
let bullets=[],enemies=[],particles=[];
let keys={},idleMode=false,idleInterval=null;
let combo=0,mass=0,difficulty=1,hUses=12;
let survivorStreak = 0;


// ==== SURVIVOR MODE ====
let gameMode = "classic"; // "classic" or "survivor"
gameMode = "menu"; // menu is active by default
let hearts = 3;
let highScore = localStorage.getItem("highScore") || 0;
document.getElementById("highScore").textContent = highScore;
let maxHearts = 6;
let kills = 0;
let invulnerable = false;
let invulnTimer = 0;
let dead = false;
let deathStartTime = 0;
let scoreDisplay = 0;

// ===== DONUT (TORUS) PARTICLES =====
const donutParticles = [];
const DONUT_COUNT = 900;

for (let i = 0; i < DONUT_COUNT; i++) {
  donutParticles.push({
    theta: Math.random() * Math.PI * 2,
    phi: Math.random() * Math.PI * 2,
    speed: Math.random() * 0.002 + 0.001,
    size: Math.random() * 1.5 + 0.8,
    hue: Math.random() * 360
  });
}



/* ==== BLUE CUBE ==== */
  const blueCubeImg = new Image();
blueCubeImg.src = "bluecube.png";

let blueCube=null,nextCubeSpawn=Date.now()+30000,enemyOriginalSpeeds=new Map();
function updateBlueCube(deltaTime){
  if(!blueCube && Date.now()>=nextCubeSpawn){
   blueCube={
  x:50+Math.random()*(canvas.width-100),
  y:50+Math.random()*(canvas.height-100),
  size:80,
  speed:80,
  angle:0
};

  }
  if(blueCube){
    const dx=blueCube.x-player.x,dy=blueCube.y-player.y,dist=Math.hypot(dx,dy)||1;
    const moveDist=blueCube.speed*deltaTime/1000;
    blueCube.x+=(dx/dist)*moveDist; blueCube.y+=(dy/dist)*moveDist;
    blueCube.x=Math.max(blueCube.size/2,Math.min(canvas.width-blueCube.size/2,blueCube.x));
    blueCube.y=Math.max(blueCube.size/2,Math.min(canvas.height-blueCube.size/2,blueCube.y));
    if(dist<blueCube.size/2+player.r){
      enemies.forEach(e=>{ if(!enemyOriginalSpeeds.has(e)) enemyOriginalSpeeds.set(e,0.7+difficulty*0.2); e.speed=(0.7+difficulty*0.2)*0.2; });
      blueCube=null; nextCubeSpawn=Date.now()+(30000+Math.random()*30000);
      setTimeout(()=>{ enemies.forEach(e=>{ e.speed=enemyOriginalSpeeds.get(e)|| (0.7+difficulty*0.2); }); enemyOriginalSpeeds.clear(); },5000);
    }
  }
}
function drawBlueCube(){
  if(!blueCube || !blueCubeImg.complete) return;

  blueCube.angle += 0.05;

  ctx.save();
  ctx.translate(blueCube.x, blueCube.y);
  ctx.rotate(blueCube.angle);


  ctx.shadowColor = "rgba(173,216,230,0.5)"; // soft blue glow
ctx.shadowBlur = 12; // less glow


  ctx.drawImage(
    blueCubeImg,
    -blueCube.size/2,
    -blueCube.size/2,
    blueCube.size,
    blueCube.size
  );

  ctx.restore();
}


/* ==== CAMERA SHAKE ==== */
let shakeAmount=0;
function shakeCamera(amount){ shakeAmount=amount; }

/* ==== FIRE ==== */
function fireSingle(){ 
  const spread=0.2; 
  let shots = bulletMultiplier;
  for(let s=0;s<shots;s++){
    if(player.rainbow){ for(let i=-1;i<=2;i++){ const a=player.angle+i*spread; bullets.push({x:player.x,y:player.y,vx:Math.cos(a)*6,vy:Math.sin(a)*6,rainbow:true}); } }
    else bullets.push({x:player.x,y:player.y,vx:Math.cos(player.angle)*6,vy:Math.sin(player.angle)*6,rainbow:false});
  }
}
function fireSpread(){ const count=8; for(let i=0;i<count;i++){ const a=i*Math.PI*2/count+player.angle; bullets.push({x:player.x,y:player.y,vx:Math.cos(a)*7,vy:Math.sin(a)*7,rainbow:player.rainbow}); } }

/* ==== EVOLUTION ==== */
let pixelated=false;
const shapeOrder=[3,4,5,6,7,8,9,10,2,50,60,70,80,90,101,102,103,104,100];
function evolve(){
  if(!pixelated){
    if(player.tokens<5) currentShapeSides=3;
    else if(player.tokens<10) currentShapeSides=4;
    else if(player.tokens<15) currentShapeSides=5;
    else if(player.tokens<20) currentShapeSides=6;
    else if(player.tokens<25) currentShapeSides=7;
    else if(player.tokens<30) currentShapeSides=8;
    else if(player.tokens<35) currentShapeSides=9;
    else if(player.tokens<40) currentShapeSides=10;
    else if(player.tokens<45) currentShapeSides=2;
    else if(player.tokens<50) currentShapeSides=50;
    else if(player.tokens<55) currentShapeSides=60;
    else if(player.tokens<60) currentShapeSides=70;
    else if(player.tokens<65) currentShapeSides=80;
    else if(player.tokens<70) currentShapeSides=90;
    else if(player.tokens<75) currentShapeSides=101;
    else if(player.tokens<80) currentShapeSides=102;
    else if(player.tokens<85) currentShapeSides=103;
    else if(player.tokens<90) currentShapeSides=104;
    else currentShapeSides=100;
    if(currentShapeSides===100) pixelated=true;
  } else { 
    const pixelOrder=[3,4,5,6,7,8,9,10,100];
    const idx=pixelOrder.indexOf(currentShapeSides);
    currentShapeSides=pixelOrder[Math.min(idx+1,pixelOrder.length-1)];
  }
  bulletMultiplier=(currentShapeSides===100)?2:1;
  restartIdleIfActive();

}

/* ==== ENEMIES ==== */
function spawnEnemy(){
    const types = ["normal", "splitter", "orbital", "tank"];
    const type = types[Math.floor(Math.random() * types.length)];

    let r, speed, x, y, hp;

   // Spawn at random edge
switch(type){
   case "splitter":
    const edge = Math.floor(Math.random()*4);
    if(edge===0){ x=-20; y=Math.random()*canvas.height; }
    else if(edge===1){ x=canvas.width+20; y=Math.random()*canvas.height; }
    else if(edge===2){ x=Math.random()*canvas.width; y=-20; }
    else { x=Math.random()*canvas.width; y=canvas.height+20; }
    break;
    default:
        if(Math.random() < 0.5){ x = -20; } else { x = canvas.width + 20; }
        y = Math.random() * canvas.height;
}

    // Assign properties based on type
    switch(type){
        case "normal":
            r = 8;
            speed = 0.7 + difficulty * 0.2;
            hp = 1;
            break;

        case "splitter":
            r = 12; // big oval
            speed = 0.6 + difficulty * 0.2;
            hp = 1;
            break;

        case "orbital":
            r = 8;
            speed = 0.5 + difficulty * 0.15;
            hp = 1;
            break;

        case "tank":
            r = 16; // 2x bigger
            speed = 0.35 + difficulty * 0.1; // 2x slower
            hp = 2; // 2x damage
            break;
    }

    if(hardMode) speed *= 1.7;

    enemies.push({ x, y, r, speed, type, hp, orbitAngle: 0, hasSplit: false });
}

  setInterval(() => {
    if(!gamePaused && !dead && gameMode !== "menu") spawnEnemy();
}, 800);

setInterval(()=>{hUses=12;},60000);

/* ==== EXPLOSIONS ==== */
function createExplosion(x,y){
  for(let i=0;i<12;i++){
    particles.push({x,y,r:Math.random()*4+2,vx:(Math.random()-0.5)*5,vy:(Math.random()-0.5)*5,alpha:1});
  }
}

/* ==== COMBO ==== */
function showCombo(n){
  const d=document.createElement('div'); d.className='comboText'; d.textContent='COMBO x'+n;
  d.style.color=player.rainbow?`hsl(${Date.now()%360},100%,50%)`:'#fff';
  document.body.appendChild(d); setTimeout(()=>d.remove(),1000);
}

/* ==== SHAPE NAMES ==== */
function getShapeName(sides){
  switch(sides){
    case 3: return "Triangle";
    case 4: return "Square";
    case 5: return "Pentagon";
    case 6: return "Hexagon";
    case 7: return "Heptagon";
    case 8: return "Octagon";
    case 9: return "Nonagon";
    case 10: return "Decagon";
    case 2: return "Digon";
    case 50: return "4-sided Star";
    case 60: return "6-sided Star";
    case 70: return "7-sided Star";
    case 80: return "5-point Star";
    case 90: return "6-point Star";
    case 101: return "Hexagram";
    case 102: return "Heptagram";
    case 103: return "Heart";
    case 104: return "Diamond";
    case 100: return "Circle";
    default: return "Unknown";
  }
}

/* ==== UPDATE ==== */

function renderHearts(){
  const ui = document.getElementById("heartsUI");
  ui.innerHTML = "";
  if(gameMode !== "survivor") return;

  for(let i = 0; i < hearts; i++){
    const h = document.createElement("div");
    h.className = "heart";
    ui.appendChild(h);
  }
}

function update(){
  let slowMo = (gameMode === "survivor" && hearts === 1);
  if(dead) return;

  const now=performance.now();
  if(!idleMode){ if(keys.w)player.y-=4; if(keys.s)player.y+=4; if(keys.a)player.x-=4; if(keys.d)player.x+=4; }
  else{ player.x+=(canvas.width/2-player.x)*0.05; player.y+=(canvas.height/2-player.y)*0.05; }
  player.angle+=0.08;

  bullets.forEach((b,i)=>{ b.x+=b.vx; b.y+=b.vy; if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height) bullets.splice(i,1); });

  enemies.forEach((e,i)=>{
   const dx = player.x - e.x;
const dy = player.y - e.y;
const dist = Math.hypot(dx, dy) || 1;
const speedMult = slowMo ? 0.5 : 1;

switch(e.type){
    case "normal":
        e.x += dx/dist * e.speed * speedMult;
        e.y += dy/dist * e.speed * speedMult;
        break;

    case "splitter":
    const splitDistance = 60; // distance to split
    if(!e.hasSplit && dist < splitDistance){
        if(!e.splitDelay) e.splitDelay = 15; // frames to pause before splitting
        e.splitDelay--;
        if(e.splitDelay <= 0){
           for(let j=0;j<2;j++){
    const angle = Math.random()*Math.PI*2;
    enemies.push({
        x: e.x + Math.cos(angle)*40, // farther split (was 10)
        y: e.y + Math.sin(angle)*40, // farther split
        r: e.r * 0.5,                // still half the parent size
        speed: e.speed * 1.5,        // 1.5x faster
        type: "splitterChild",
        hp: 1,
        orbitAngle: 0,
        hasSplit: false,
        dx: 0,                       // placeholder for velocity
        dy: 0
    });
}

            e.hasSplit = true;
            enemies.splice(i,1);
        }
    } else if(!e.hasSplit){
        e.x += dx/dist * e.speed * speedMult;
        e.y += dy/dist * e.speed * speedMult;
    }
    break;


    case "orbital":
    const orbitTriggerDist = 150;  // distance to start orbiting
    const orbitRadius = 80;        // radius of orbit
    const orbitSpeed = 0.03;       // slow orbit speed
    const homeSpeedMult = 2;       // after orbit, moves faster

    if(!e.startedOrbit && dist < orbitTriggerDist){
        // Start orbiting
        e.startedOrbit = true;
        e.orbitProgress = 0;
        e.orbitCount = Math.floor(Math.random()*2)+1; // 1 or 2 full orbits
    }

    if(e.startedOrbit && e.orbitProgress < e.orbitCount * Math.PI * 2){
        // Orbiting phase
        e.orbitProgress += orbitSpeed;
        e.x = player.x + Math.cos(e.orbitProgress) * orbitRadius;
        e.y = player.y + Math.sin(e.orbitProgress) * orbitRadius;
    } else if(e.startedOrbit && e.orbitProgress >= e.orbitCount * Math.PI * 2){
        // Orbit finished, home in quickly
        e.x += dx/dist * e.speed * speedMult * homeSpeedMult;
        e.y += dy/dist * e.speed * speedMult * homeSpeedMult;
    } else {
        // Normal movement toward player
        e.x += dx/dist * e.speed * speedMult;
        e.y += dy/dist * e.speed * speedMult;
    }
    break;

    case "tank":
        e.x += dx/dist * e.speed * speedMult;
        e.y += dy/dist * e.speed * speedMult;
        break;
}


// COLLISION WITH PLAYER
if(dist < player.r + e.r){
    if(gameMode === "survivor"){
        if(!invulnerable){
            hearts--;
            invulnerable = true;
            invulnTimer = 120;
            shakeCamera(12);
            if(hearts <= 0) triggerDeathScreen();
        }
        enemies.splice(i,1);
    } else {
        const idx = shapeOrder.indexOf(currentShapeSides);
        currentShapeSides = shapeOrder[Math.max(0, idx - 3)];
        restartIdleIfActive();
        combo = 0;
        survivorStreak = 0;
        player.rainbow = false;
        shakeCamera(5);
        enemies.splice(i,1);
    }
}

  // Make splitter children move toward the player
if(e.type === "splitterChild"){
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy) || 1; // prevent divide by zero
    e.x += dx / dist * e.speed;
    e.y += dy / dist * e.speed;
}

// REMOVE OFFSCREEN
if(e.x<-50||e.x>canvas.width+50||e.y<-50||e.y>canvas.height+50) enemies.splice(i,1);

  });

  bullets.forEach((b,bi)=>{
    enemies.forEach((e,ei)=>{
      if(Math.hypot(b.x-e.x,b.y-e.y)<e.r){ bullets.splice(bi,1); enemies.splice(ei,1); createExplosion(e.x,e.y); if(gameMode === "survivor") {  // ONLY in survivor mode
    mass++;  // increase score
    if(mass > highScore){
        highScore = mass;
        localStorage.setItem("highScore", highScore);
        document.getElementById("highScore").textContent = highScore;
    }
    player.tokens++;
}
 evolve(); kills++;  if(gameMode === "survivor" && kills % 150 === 0){   hearts = Math.min(maxHearts, hearts + 1); } combo++;

if (gameMode === "survivor") {
  survivorStreak++;

  if (survivorStreak === 10) {
    player.rainbow = true;
  }

  if (survivorStreak === 20) {
    hearts = Math.min(maxHearts, hearts + 1);
  }
}
 shakeCamera(8); if(mass%20===0)difficulty++; if(combo>1)showCombo(combo); if(combo>=35&&!player.rainbow)player.rainbow=true; }
    });
  });

  particles.forEach((p,i)=>{ p.x+=p.vx; p.y+=p.vy; p.alpha-=0.03; if(p.alpha<=0)particles.splice(i,1); });

  bgObj.x+=bgObj.vx; bgObj.y+=bgObj.vy; if(bgObj.x<bgObj.size||bgObj.x>canvas.width-bgObj.size) bgObj.vx*=-1; if(bgObj.y<bgObj.size||bgObj.y>canvas.height-bgObj.size) bgObj.vy*=-1;
  bgObj2.x+=bgObj2.vx; bgObj2.y+=bgObj2.vy; if(bgObj2.x<bgObj2.size||bgObj2.x>canvas.width-bgObj2.size) bgObj2.vx*=-1; if(bgObj2.y<bgObj2.size||bgObj2.y>canvas.height-bgObj2.size) bgObj2.vy*=-1;

  document.getElementById('mass').textContent=mass;
  document.getElementById('tokens').textContent=player.tokens;
  document.getElementById('tier').textContent=getShapeName(currentShapeSides);
  player.x=Math.max(player.r,Math.min(canvas.width-player.r,player.x));
  player.y=Math.max(player.r,Math.min(canvas.height-player.r,player.y));

  if(invulnerable){
  invulnTimer--;
  if(invulnTimer <= 0){
    invulnerable = false;
  }
}


  updateBlueCube(now-(updateBlueCube.lastTime||now));
  renderHearts();

  updateBlueCube.lastTime=now;

  checkCircleMessage();
}

/* ==== CIRCLE MESSAGE ==== */
let circleMessageShown=false;
function checkCircleMessage(){
  if(currentShapeSides===100 && !circleMessageShown){
    circleMessageShown=true;
    const msg=document.createElement('div'); msg.textContent="whoa, ur a circle now. HIGH FIVE! ðŸ˜œ";
    msg.style.position='fixed'; msg.style.bottom='20px'; msg.style.left='50%'; msg.style.transform='translateX(-50%)';
    msg.style.fontFamily="'SF Pro', sans-serif"; msg.style.fontWeight='600'; msg.style.fontStyle='italic'; msg.style.fontSize='22px';
    msg.style.color='white'; msg.style.pointerEvents='none'; msg.style.zIndex='999'; msg.style.opacity='1'; document.body.appendChild(msg);
    let hue=0;
    const rainbowInterval=setInterval(()=>{ hue=(hue+3)%360; msg.style.color=`hsl(${hue},100%,50%)`; },30);
    setTimeout(()=>{
      let opacity=1; const fadeInterval=setInterval(()=>{ opacity-=0.02; msg.style.opacity=opacity; if(opacity<=0){ clearInterval(fadeInterval); clearInterval(rainbowInterval); msg.remove(); } },30);
    },5000);
  }
}

/* ==== DRAW ==== */
function triggerDeathScreen(){
  dead = true;
  gamePaused = true;
  deathStartTime = performance.now();

  // SHOW BACK BUTTON ONLY FOR SURVIVOR MODE
  if(gameMode === "survivor"){
    document.getElementById("backBtn").style.display = "block";
  }
}


function drawDonut(ctx, time, cx, cy) {
  const R = 120;
  const r = 55;

  donutParticles.forEach(p => {
    p.theta += p.speed * 2;
    p.phi += p.speed;

    const x3D = (R + r * Math.cos(p.phi)) * Math.cos(p.theta);
    const y3D = (R + r * Math.cos(p.phi)) * Math.sin(p.theta);
    const z3D = r * Math.sin(p.phi);

    const scale = 0.7 + z3D / 160;
    const x2D = cx + x3D * scale;
    const y2D = cy + y3D * scale;

    ctx.beginPath();
    ctx.fillStyle = `hsla(${p.hue + time * 0.05}, 100%, 60%, 0.85)`;
    ctx.arc(x2D, y2D, p.size * scale, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawVHS(ctx, w, h, time) {

 const danger = Math.min(enemies.length / 15, 1);
ctx.fillStyle = `rgba(0,0,0,${0.15 + danger * 0.25})`;
  for (let y = 0; y < h; y += 3) {
    ctx.fillRect(0, y, w, 1);
  }

  const shift = Math.sin(time * 0.004) * 2;
  ctx.globalCompositeOperation = "screen";

  ctx.drawImage(canvas, shift, 0);
  ctx.drawImage(canvas, -shift, 0);

  ctx.globalCompositeOperation = "source-over";

  for (let i = 0; i < 200; i++) {
    const x = Math.random() * w;
    const y = Math.random() * h;
    ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.04})`;
    ctx.fillRect(x, y, 1, 1);
  }

  const grad = ctx.createRadialGradient(
    w/2, h/2, w*0.2,
    w/2, h/2, w*0.7
  );
  grad.addColorStop(0, "rgba(0,0,0,0)");
  grad.addColorStop(1, "rgba(0,0,0,0.4)");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h);
}

function draw(){
  ctx.save();
  const shakeX=(Math.random()-0.5)*shakeAmount, shakeY=(Math.random()-0.5)*shakeAmount;
  ctx.translate(shakeX,shakeY); shakeAmount*=0.9;
 ctx.fillStyle = colorMode === "light" ? "#fff" : "#000"; // solid background
ctx.fillRect(0, 0, canvas.width, canvas.height);

  if(bgImg.complete){ ctx.globalAlpha=0.25; bgObj.angle += 0.002;

ctx.save();
ctx.translate(bgObj.x, bgObj.y);
ctx.rotate(bgObj.angle);
ctx.drawImage(bgImg, -bgObj.size/2, -bgObj.size/2, bgObj.size, bgObj.size);
ctx.restore();
 ctx.globalAlpha=1; }
  if(bgImg2.complete){ ctx.globalAlpha=0.25; ctx.drawImage(bgImg2,bgObj2.x-bgObj2.size/2,bgObj2.y-bgObj2.size/2,bgObj2.size,bgObj2.size); ctx.globalAlpha=1; }
  drawPlayerShape();
bullets.forEach(b => {
  // Decide bullet color based on rainbow power or mode
  const baseColor = b.rainbow
    ? `hsl(${Date.now()%360},100%,50%)` // rainbow bullets
    : (colorMode === "light" ? "#000" : "#fff"); // black for light mode, white for dark mode

  // Add a soft glow so bullets pop through VHS
ctx.shadowColor = colorMode === "light" ? "#000" : "#fff"; // glow matches bullet color
ctx.shadowBlur = 6; // more visible through VHS


  // Draw the bullet as a tiny square
  ctx.fillStyle = baseColor;
  ctx.fillRect(b.x, b.y, 3, 3);

  // Reset glow for everything else
  ctx.shadowBlur = 0;
});



  enemies.forEach(e=>{
ctx.save();
ctx.translate(e.x, e.y);
ctx.rotate(player.angle); // make enemy rotate like player

// Add glow for enemy
let glowColor;
switch(e.type){
    case "normal": glowColor = "rgba(255,0,0,0.25)"; break;
    case "splitter": 
    case "splitterChild": glowColor = "rgba(91,180,80,0.25)"; break;
    case "orbital": glowColor = "rgba(78,159,229,0.25)"; break;
    case "tank": glowColor = "rgba(175,105,238,0.25)"; break;
    default: glowColor = "rgba(255,255,255,0.25)";
}
ctx.shadowColor = glowColor;
ctx.shadowBlur = 6; // blueCube has 12, so half


if(e.type === "normal"){
  ctx.fillStyle = 'red';
  ctx.beginPath();
  ctx.arc(0, 0, e.r, 0, Math.PI*2);
  ctx.fill();
} 
else if(e.type === "splitter"){
  ctx.fillStyle = '#5bb450';
  ctx.beginPath();
  ctx.ellipse(0, 0, e.r*1.2, e.r*0.8, 0, 0, Math.PI*2);
  ctx.fill();
} 
else if(e.type === "splitterChild"){
  ctx.fillStyle = '#5bb450'; // same color as parent
  ctx.beginPath();
  ctx.arc(0, 0, e.r, 0, Math.PI*2); // plain circle
  ctx.fill();
}
else if(e.type === "orbital"){
  ctx.fillStyle = '#4E9FE5';
  const spikes = 8;
  const inner = e.r * 0.6;
  const outer = e.r;
  ctx.beginPath();
  for(let i=0;i<spikes*2;i++){
    const radius = i % 2 === 0 ? outer : inner;
    const angle = (i * Math.PI) / spikes;
    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
  }
  ctx.closePath();
  ctx.fill();
} 
else if(e.type === "tank"){
  ctx.fillStyle = '#AF69EE';
  ctx.beginPath();
  ctx.arc(0, 0, e.r, 0, Math.PI*2);
  ctx.fill();
}

ctx.restore();

});

  particles.forEach(p=>{ ctx.fillStyle=`rgba(255,0,0,${p.alpha})`; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); });
  drawDonut(ctx, performance.now(), canvas.width / 2, canvas.height / 2);
  drawBlueCube();

  drawVHS(ctx, canvas.width, canvas.height, performance.now());

/* ==== SURVIVOR DEATH SCREEN ==== */
if(dead){
  const elapsed = performance.now() - deathStartTime;

  const alpha = Math.min(1, elapsed / 1200);

  ctx.fillStyle = `rgba(0,0,0,${alpha})`;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.textAlign = "center";
  ctx.fillStyle = "white";
  ctx.globalAlpha = alpha;

  ctx.font = "bold 80px SF Pro Display";
  ctx.fillText(
    "YOU DIED",
    canvas.width/2,
    canvas.height/2 - 60 + (1 - alpha) * 40
  );

  const progress = Math.min(elapsed / 5000, 1);
  scoreDisplay = Math.floor(mass * progress);

  ctx.font = "bold 36px SF Pro Display";
  ctx.fillText(
    `Score: ${scoreDisplay}`,
    canvas.width/2,
    canvas.height/2 + 40
  );

ctx.font = "20px SF Pro Display";
ctx.fillText(
  `Streak Bonus: ${survivorStreak}`,
  canvas.width/2,
  canvas.height/2 + 80
);


  ctx.globalAlpha = 1;
}  
  ctx.restore();

}
  

/* ==== DRAW PLAYER ==== */
function drawPlayerShape(){
  const s=currentShapeSides;
  ctx.save(); ctx.translate(player.x,player.y); ctx.rotate(player.angle); ctx.fillStyle=player.rainbow?`hsl(${Date.now()%360},100%,50%)`:'#4caf50'; ctx.beginPath();
  if([3,4,5,6,7,8,9,10].includes(s)){ for(let i=0;i<s;i++){ const a=i*Math.PI*2/s-Math.PI/2; ctx.lineTo(Math.cos(a)*player.r,Math.sin(a)*player.r); } ctx.closePath(); } 
  else if(s===100){ctx.arc(0,0,player.r,0,Math.PI*2);} 
  else if(s===2){ctx.moveTo(-player.r,0); ctx.quadraticCurveTo(0,-player.r,player.r,0); ctx.quadraticCurveTo(0,player.r,-player.r,0); ctx.closePath();}
  else if([50,60,70,80,90,101,102].includes(s)){ let spikes; switch(s){ case 50:spikes=4;break; case 60:spikes=6;break; case 70:spikes=7;break; case 80:spikes=5;break; case 90:spikes=6;break; case 101:spikes=6;break; case 102:spikes=7;break;} for(let i=0;i<spikes*2;i++){ let r=i%2===0?player.r:player.r/2; if(s===101||s===102) r=i%2===0?player.r:player.r/3; const a=i*Math.PI/spikes-Math.PI/2; ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r);} ctx.closePath();}
  else if(s===103){ ctx.moveTo(0,-player.r/2); ctx.bezierCurveTo(player.r,-player.r*1.2,player.r*1.5,player.r/3,0,player.r); ctx.bezierCurveTo(-player.r*1.5,player.r/3,-player.r,-player.r*1.2,0,-player.r/2); ctx.closePath();}
  else if(s===104){ ctx.moveTo(0,-player.r); ctx.lineTo(player.r/2,0); ctx.lineTo(0,player.r); ctx.lineTo(-player.r/2,0); ctx.closePath();}
  ctx.fill(); ctx.restore();
}

/* ==== LOOP ==== */
let gamePaused=true;
function loop(){
  requestAnimationFrame(loop);

  if (!gamePaused) {
    update();
  }

  draw(); // ALWAYS draw (needed for death screen)
}

loop();

/* ==== INPUT ==== */
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;

  // FIRE
  if(e.key === ' ' && !idleMode) fireSingle();
  if(e.key.toLowerCase() === 'h' && !idleMode && hUses>0) { fireSpread(); hUses--; }

  // BACKSPACE / ESC
  if (e.key === "Backspace" || e.key === "Escape") {

    // Close SETTINGS
    if(settingsOptions.style.display === "block"){
      settingsOptions.style.display = "none";
      modeSelect.style.display = "flex";
      return;
    }

    // Close CLASSIC OPTIONS
    if(classicOptions.style.display === "block"){
      classicOptions.style.display = "none";
      modeSelect.style.display = "flex";
      return;
    }

    // Close ARCADE OPTIONS
    if(arcadeOptions.style.display === "block"){
      arcadeOptions.style.display = "none";
      modeSelect.style.display = "flex";
      return;
    }

    // Survivor back button when dead
    if(dead){
      document.getElementById("backBtn").click();
      return;
    }

    // Toggle pause if in game
    gamePaused = !gamePaused;
  }
});

window.addEventListener('keyup', e => { 
  keys[e.key.toLowerCase()] = false; 
});

  window.addEventListener('keyup', e => {     keys[e.key.toLowerCase()] = false; });
window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });

/* ==== CATALOG ==== */
const catalogItems = [
  { id: 'rainbow', name: 'RAINBOW MODE', type: 'Power', description: 'Shoots rainbow bullets.', unlocked: false },
  { id: 'blueCube', name: 'BLUE CUBE', type: 'Power', description: 'Special cube that chases you.', unlocked: false },
  { id: 'orbital', name: 'ORBITAL ENEMY', type: 'Enemy', hp: 1, damage: 1, speed: 0.5, description: 'Orbits then homes in.', unlocked: false },
  { id: 'splitter', name: 'SPLITTER ENEMY', type: 'Enemy', hp: 1, damage: 1, speed: 0.6, description: 'Splits into two children.', unlocked: false },
  { id: 'tank', name: 'TANK ENEMY', type: 'Enemy', hp: 2, damage: 2, speed: 0.35, description: 'Big and slow.', unlocked: false }
];

let catalogIndex = 0;

// Update unlocked items based on game progress
function updateCatalogUnlocks(){
  catalogItems.forEach(item=>{
    if(item.id==='rainbow') item.unlocked = player.rainbow || item.unlocked;
    if(item.id==='blueCube') item.unlocked = !!blueCube || item.unlocked;
    if(item.id==='orbital') item.unlocked = enemies.some(e=>e.type==='orbital') || item.unlocked;
    if(item.id==='splitter') item.unlocked = enemies.some(e=>e.type==='splitter') || item.unlocked;
    if(item.id==='tank') item.unlocked = enemies.some(e=>e.type==='tank') || item.unlocked;
  });
}

// Render catalog
function renderCatalog(){
  const container = document.getElementById('catalogContent');
  const item = catalogItems[catalogIndex];
  updateCatalogUnlocks();
  
  container.innerHTML = '';

  if(item.unlocked){
    const name = document.createElement('h2'); name.textContent = item.name; container.appendChild(name);
    const type = document.createElement('p'); type.textContent = 'Type: ' + item.type; container.appendChild(type);
    if(item.type==='Enemy'){
      const stats = document.createElement('p'); stats.textContent = `HP: ${item.hp}, Damage: ${item.damage}, Speed: ${item.speed}`; container.appendChild(stats);
    }
    const desc = document.createElement('p'); desc.textContent = item.description; container.appendChild(desc);
    const circle = document.createElement('div');
    circle.style.width = '100px'; circle.style.height='100px'; circle.style.borderRadius='50%';
    circle.style.margin='20px auto';
    circle.style.background = item.type==='Power' ? 'linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)' : '#888';
    container.appendChild(circle);
  } else {
    // Locked: show shadow only
    const locked = document.createElement('div');
    locked.style.width='100px'; locked.style.height='100px'; locked.style.borderRadius='50%';
    locked.style.margin='20px auto';
    locked.style.background='#000';
    locked.style.boxShadow='0 0 10px #555 inset';
    container.appendChild(locked);
    const name = document.createElement('h2'); name.textContent = '???'; container.appendChild(name);
  }
}

// Show catalog
document.getElementById('catalogBtn').addEventListener('click', ()=>{
  document.getElementById('catalogPanel').style.display='block';
  gamePaused = true;
  renderCatalog();
});

// Close catalog
document.getElementById('catalogCloseBtn').addEventListener('click', ()=>{
  document.getElementById('catalogPanel').style.display='none';
  gamePaused = false;
});

// Navigate catalog with buttons
document.getElementById('catalogLeftBtn').addEventListener('click', ()=>{
  catalogIndex = (catalogIndex - 1 + catalogItems.length) % catalogItems.length;
  renderCatalog();
});
document.getElementById('catalogRightBtn').addEventListener('click', ()=>{
  catalogIndex = (catalogIndex + 1) % catalogItems.length;
  renderCatalog();
});

// Navigate catalog with A/D keys
window.addEventListener('keydown', e=>{
  if(document.getElementById('catalogPanel').style.display==='block'){
    if(e.key.toLowerCase() === 'a'){
      catalogIndex = (catalogIndex - 1 + catalogItems.length) % catalogItems.length;
      renderCatalog();
    }
    if(e.key.toLowerCase() === 'd'){
      catalogIndex = (catalogIndex + 1) % catalogItems.length;
      renderCatalog();
    }
  }
});


/* ==== IDLE MODE ==== */

 function getIdleFireInterval(){
  const baseInterval = 1000; // triangle speed
  const idx = shapeOrder.indexOf(currentShapeSides);
  const tier = Math.max(0, idx); // progression-based tier
  return baseInterval / Math.pow(1.07, tier);
}


function restartIdleIfActive(){
  if(idleMode){
    clearInterval(idleInterval);
    idleInterval = setInterval(()=>{
  fireSpread();
}, getIdleFireInterval());

  }
}

document.getElementById('idleBtn').onclick=()=>{
  if(idleMode) return;
  idleMode = true;

  document.getElementById('idleBtn').style.display='none';
  document.getElementById('exitIdleBtn').style.display='block';

  restartIdleIfActive();
};

document.getElementById('exitIdleBtn').onclick=()=>{
  idleMode=false; clearInterval(idleInterval); idleInterval=null;
  document.getElementById('exitIdleBtn').style.display='none'; document.getElementById('idleBtn').style.display='block';
};

/* ==== SAVE / LOAD ==== */
const savePanel=document.getElementById("savePanel");
const saveText=document.getElementById("saveText");
document.getElementById("saveLoadBtn").onclick=()=>{ savePanel.style.display="block"; saveText.value=""; gamePaused=true; };
document.getElementById("closeSave").onclick=()=>{ savePanel.style.display="none"; gamePaused=false; };
document.getElementById("saveBtn").onclick=()=>{
  const data={ mass, tokens:player.tokens, combo, currentShapeSides, playerRainbow:player.rainbow, playerX:player.x, playerY:player.y, pixelated, enemies:enemies.map(e=>({x:e.x,y:e.y,r:e.r,hp:e.hp})) };
  saveText.value=btoa(JSON.stringify(data));
};
document.getElementById("loadBtn").onclick=()=>{
  try{
    const data=JSON.parse(atob(saveText.value.trim()));
    mass=data.mass ?? mass;
    player.tokens=data.tokens ?? player.tokens;
    combo=data.combo ?? combo;
    currentShapeSides=data.currentShapeSides ?? currentShapeSides;
    player.rainbow=!!data.playerRainbow;
    player.x=data.playerX ?? player.x;
    player.y=data.playerY ?? player.y;
    pixelated=data.pixelated ?? false;
    enemies=data.enemies ?? [];
    savePanel.style.display="none"; gamePaused=false;
    bulletMultiplier=(currentShapeSides===100)?2:1;
  }catch{ alert("Invalid save code"); }
};

/* ==== TITLE SCREEN PIXELATION TRANSITION ==== */
const transitionCanvas=document.getElementById("transitionCanvas"); const tCtx=transitionCanvas.getContext("2d");
transitionCanvas.width=innerWidth; transitionCanvas.height=innerHeight;
window.addEventListener('resize',()=>{transitionCanvas.width=innerWidth; transitionCanvas.height=innerHeight;});
function pixelateTransition(callback){
  transitionCanvas.style.display="block";
  const w=transitionCanvas.width,h=transitionCanvas.height;
  tCtx.fillStyle="#0b0b0b"; tCtx.fillRect(0,0,w,h);
  let source=tCtx.getImageData(0,0,w,h);
  let start=null,duration=700,switched=false;
  function drawPixels(block){
    tCtx.clearRect(0,0,w,h);
    for(let y=0;y<h;y+=block){ for(let x=0;x<w;x+=block){ const i=(y*w+x)*4; const r=source.data[i],g=source.data[i+1],b=source.data[i+2]; tCtx.fillStyle=`rgb(${r},${g},${b})`; tCtx.fillRect(x,y,block,block); } }
  }
  function animate(ts){
    if(!start) start=ts; const t=(ts-start)/duration;
    const eased=t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
    const block=Math.max(1,Math.floor(eased*64));
    drawPixels(block);
    if(t>0.5 && !switched){ switched=true; document.getElementById("titleScreen").style.display="none"; gamePaused=false; update(); draw(); source=ctx.getImageData(0,0,w,h); if(callback) callback();}
    if(t<1) requestAnimationFrame(animate); else transitionCanvas.style.display="none";
  }
  requestAnimationFrame(animate);
}

/* ==== TITLE SCREEN BUTTONS ==== */
const modeSelect = document.getElementById("modeSelect");
const classicOptions = document.getElementById("classicOptions");
const arcadeOptions = document.getElementById("arcadeOptions");
  const settingsOptions = document.getElementById("settingsOptions");

const btnHoverSound = document.getElementById("btnHover");
const btnClickSound = document.getElementById("btnClick");

document.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("mouseenter", () => {
        btnHoverSound.currentTime = 0;
        btnHoverSound.play();
    });
    btn.addEventListener("click", () => {
        btnClickSound.currentTime = 0;
        btnClickSound.play();
    });
});


document.getElementById("classicBtn").onclick = () => {
  gameMode = "menu"; // EXACT LINE: still in menu while selecting
  modeSelect.style.display = "none";
  arcadeOptions.style.display = "none";
  classicOptions.style.display = "block";
};

document.getElementById("arcadeBtn").onclick = () => {
  gameMode = "menu"; // EXACT LINE: still in menu while selecting
  modeSelect.style.display = "none";
  classicOptions.style.display = "none";
  arcadeOptions.style.display = "block";
};
document.getElementById("settingsBtn").onclick = () => {
  gameMode = "menu"; // EXACT LINE: still in menu while selecting
  modeSelect.style.display = "none";
  classicOptions.style.display = "none";
  arcadeOptions.style.display = "none";
  settingsOptions.style.display = "block";
};
document.getElementById('catalogBtn').onclick = () => {
  catalogPanel.style.display = 'block';
  modeSelect.style.display = 'none';
};

document.getElementById('catalogCloseBtn').onclick = () => {
  catalogPanel.style.display = 'none';
  modeSelect.style.display = 'flex';
};


  
document.getElementById('hardBtn').onclick = () => {
  menuMusic.pause();
  menuMusic.currentTime = 0;

  gameMusic.currentTime = 0;
  gameMusic.play().catch(()=>console.log("Game music blocked"));

  pixelateTransition(() => {
    hardMode = true;
    difficulty *= 2;
    gamePaused = false;
    gameMode = "classic";
  });
};

document.getElementById("survivorBtn").onclick = () => {
  menuMusic.pause();
  menuMusic.currentTime = 0;

  gameMusic.currentTime = 0;
  gameMusic.play().catch(()=>console.log("Game music blocked"));

  pixelateTransition(() => {
    gameMode = "survivor";
    hearts = 3;
    kills = 0;
    dead = false;
    invulnerable = false;
    gamePaused = false;

    document.getElementById("backBtn").style.display = "none"; // HIDE BACK BUTTON
  });
};


document.getElementById("backBtn").onclick = () => {
  gameMode = "menu";
  gamePaused = true;
  dead = false;
  gameMode = "classic";
  hearts = 3;
  kills = 0;
  invulnerable = false;
  scoreDisplay = 0;
  mass = 0;
  player.tokens = 0;
  combo = 0;

  document.getElementById("backBtn").style.display = "none"; 
  document.getElementById("titleScreen").style.display = "flex"; 

  // stop game music
  gameMusic.pause();
  gameMusic.currentTime = 0;

  // restart menu music
  menuMusic.currentTime = 0;
  menuMusic.play().catch(()=>console.log("Menu music blocked on return"));
};


document.getElementById("lightModeBtn").onclick = () => {
  colorMode = "light";
};

document.getElementById("darkModeBtn").onclick = () => {
  colorMode = "dark";
};
 
</script>
</body>
</html>
